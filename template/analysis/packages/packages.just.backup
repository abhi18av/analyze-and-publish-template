# Academic Package Development Automation
# Comprehensive tools for research package lifecycle management

# Set shell for cross-platform compatibility
set shell := ["bash", "-c"]

# Variables
project_name := "{{project_name}}"
author_name := "{{author_name}}"
author_email := "{{author_email}}"
python_version := "{{python_version|default('3.11')}}"

# Default recipe - show available commands
default:
    @echo "ðŸ“¦ Academic Package Development Commands:"
    @just --list

# === PACKAGE CREATION ===

# Create a new Python research package
create-python-package name description="Research package":
    #!/usr/bin/env bash
    package_dir="python/{{name}}"
    mkdir -p "${package_dir}"
    
    # Create package structure
    mkdir -p "${package_dir}/src/{{name}}"
    mkdir -p "${package_dir}/tests"
    mkdir -p "${package_dir}/docs"
    mkdir -p "${package_dir}/examples"
    
    # Generate pyproject.toml
    cat > "${package_dir}/pyproject.toml" << EOF
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "{{name}}"
version = "0.1.0"
description = "{{description}}"
authors = [{name = "{{author_name}}", email = "{{author_email}}"}]
readme = "README.md"
requires-python = ">={{python_version}}"
classifiers = [
    "Development Status :: 3 - Alpha",
    "Intended Audience :: Science/Research",
    "License :: OSI Approved :: MIT License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.{{python_version.split('.')[1]}}",
    "Topic :: Scientific/Engineering",
]
dependencies = [
    "numpy",
    "pandas",
    "scipy",
]

[project.optional-dependencies]
dev = [
    "pytest",
    "pytest-cov",
    "black",
    "isort",
    "flake8",
    "mypy",
]
docs = [
    "sphinx",
    "sphinx-rtd-theme",
    "myst-parser",
]
vis = [
    "matplotlib",
    "seaborn",
    "plotly",
]

[project.urls]
"Homepage" = "https://github.com/{{author_name}}/{{name}}"
"Bug Reports" = "https://github.com/{{author_name}}/{{name}}/issues"
"Source" = "https://github.com/{{author_name}}/{{name}}"

[tool.setuptools.packages.find]
where = ["src"]

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]

[tool.black]
line-length = 88
target-version = ['py{{python_version.replace('.', '')}}]

[tool.isort]
profile = "black"
line_length = 88
EOF
    
    # Create main module
    cat > "${package_dir}/src/{{name}}/__init__.py" << EOF
"""{{description}}

A research package developed as part of {{project_name}}.
"""

__version__ = "0.1.0"
__author__ = "{{author_name}}"
__email__ = "{{author_email}}"

from .core import *
from .utils import *

__all__ = [
    "__version__",
    "__author__", 
    "__email__",
]
EOF
    
    # Create core module
    cat > "${package_dir}/src/{{name}}/core.py" << EOF
"""Core functionality for {{name}} package."""

import numpy as np
import pandas as pd
from typing import Union, Optional, Tuple, List


class ResearchComponent:
    """Base class for research components.
    
    This class provides a foundation for implementing
    research algorithms and methods with consistent
    interfaces and documentation.
    """
    
    def __init__(self, name: str, **kwargs):
        """Initialize research component.
        
        Args:
            name: Name of the component
            **kwargs: Additional configuration parameters
        """
        self.name = name
        self.config = kwargs
        self._fitted = False
    
    def fit(self, data: Union[np.ndarray, pd.DataFrame]):
        """Fit the component to data.
        
        Args:
            data: Input data for fitting
            
        Returns:
            self: Fitted component
        """
        # Implement fitting logic here
        self._fitted = True
        return self
    
    def transform(self, data: Union[np.ndarray, pd.DataFrame]):
        """Transform data using fitted component.
        
        Args:
            data: Input data for transformation
            
        Returns:
            Transformed data
        """
        if not self._fitted:
            raise ValueError("Component must be fitted before transform")
        
        # Implement transformation logic here
        return data
    
    def fit_transform(self, data: Union[np.ndarray, pd.DataFrame]):
        """Fit component and transform data.
        
        Args:
            data: Input data
            
        Returns:
            Transformed data
        """
        return self.fit(data).transform(data)


def research_function(data: Union[np.ndarray, pd.DataFrame], 
                     parameter: float = 1.0) -> Union[np.ndarray, pd.DataFrame]:
    """Example research function.
    
    This function demonstrates the structure for implementing
    research algorithms with proper documentation and type hints.
    
    Args:
        data: Input data for analysis
        parameter: Research parameter (default: 1.0)
        
    Returns:
        Processed research results
        
    Examples:
        >>> import numpy as np
        >>> data = np.random.rand(100, 5)
        >>> result = research_function(data, parameter=2.0)
        >>> result.shape
        (100, 5)
    """
    # Implement research algorithm here
    if isinstance(data, pd.DataFrame):
        return data * parameter
    elif isinstance(data, np.ndarray):
        return data * parameter
    else:
        raise TypeError("Data must be numpy array or pandas DataFrame")
EOF
    
    # Create utils module
    cat > "${package_dir}/src/{{name}}/utils.py" << EOF
"""Utility functions for {{name}} package."""

import numpy as np
import pandas as pd
from pathlib import Path
from typing import Union, Dict, Any
import json


def load_research_data(filepath: Union[str, Path]) -> pd.DataFrame:
    """Load research data from various formats.
    
    Args:
        filepath: Path to data file
        
    Returns:
        Loaded data as DataFrame
    """
    filepath = Path(filepath)
    
    if filepath.suffix == '.csv':
        return pd.read_csv(filepath)
    elif filepath.suffix == '.json':
        return pd.read_json(filepath)
    elif filepath.suffix == '.parquet':
        return pd.read_parquet(filepath)
    else:
        raise ValueError(f"Unsupported file format: {filepath.suffix}")


def save_research_results(data: pd.DataFrame, 
                         filepath: Union[str, Path],
                         metadata: Dict[str, Any] = None):
    """Save research results with metadata.
    
    Args:
        data: Results data to save
        filepath: Output file path
        metadata: Optional metadata dictionary
    """
    filepath = Path(filepath)
    
    # Save data
    if filepath.suffix == '.csv':
        data.to_csv(filepath, index=False)
    elif filepath.suffix == '.parquet':
        data.to_parquet(filepath, index=False)
    else:
        raise ValueError(f"Unsupported output format: {filepath.suffix}")
    
    # Save metadata if provided
    if metadata:
        metadata_file = filepath.with_suffix('.json')
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)


def validate_research_data(data: pd.DataFrame) -> Dict[str, Any]:
    """Validate research data quality.
    
    Args:
        data: Data to validate
        
    Returns:
        Validation report dictionary
    """
    report = {
        'shape': data.shape,
        'missing_values': data.isnull().sum().to_dict(),
        'data_types': data.dtypes.to_dict(),
        'duplicates': data.duplicated().sum(),
        'memory_usage': data.memory_usage(deep=True).sum(),
    }
    
    return report
EOF
    
    # Create test file
    cat > "${package_dir}/tests/test_core.py" << EOF
"""Tests for {{name}} core functionality."""

import pytest
import numpy as np
import pandas as pd
from {{name}}.core import ResearchComponent, research_function


class TestResearchComponent:
    """Test cases for ResearchComponent class."""
    
    def test_initialization(self):
        """Test component initialization."""
        component = ResearchComponent("test")
        assert component.name == "test"
        assert not component._fitted
    
    def test_fit_transform(self):
        """Test fit and transform methods."""
        component = ResearchComponent("test")
        data = np.random.rand(10, 3)
        
        # Test fit
        result = component.fit(data)
        assert result is component
        assert component._fitted
        
        # Test transform
        transformed = component.transform(data)
        assert transformed is not None
    
    def test_fit_transform_combined(self):
        """Test combined fit_transform method."""
        component = ResearchComponent("test")
        data = np.random.rand(10, 3)
        
        result = component.fit_transform(data)
        assert result is not None
        assert component._fitted


class TestResearchFunction:
    """Test cases for research functions."""
    
    def test_numpy_input(self):
        """Test function with numpy input."""
        data = np.random.rand(5, 3)
        result = research_function(data, parameter=2.0)
        
        assert isinstance(result, np.ndarray)
        assert result.shape == data.shape
        np.testing.assert_array_equal(result, data * 2.0)
    
    def test_pandas_input(self):
        """Test function with pandas input."""
        data = pd.DataFrame(np.random.rand(5, 3))
        result = research_function(data, parameter=3.0)
        
        assert isinstance(result, pd.DataFrame)
        assert result.shape == data.shape
        pd.testing.assert_frame_equal(result, data * 3.0)
    
    def test_invalid_input(self):
        """Test function with invalid input."""
        with pytest.raises(TypeError):
            research_function([1, 2, 3])
EOF
    
    # Create README
    cat > "${package_dir}/README.md" << EOF
# {{name}}

{{description}}

## Installation

```bash
pip install -e .
```

## Development Installation

```bash
pip install -e ".[dev]"
```

## Usage

```python
import {{name}}

# Example usage
component = {{name}}.ResearchComponent("example")
result = {{name}}.research_function(data)
```

## Testing

```bash
pytest
```

## Documentation

Documentation is available in the `docs/` directory.

## Citation

If you use this package in your research, please cite:

```bibtex
@software{{{name}_{{year}},
    title = {{{{{name}}}: {{description}}},
    author = {{{{{author_name}}}}},
    year = {{{{year}}}},
    url = {{https://github.com/{{author_name}}/{{name}}}}
}
```

## License

MIT License - see LICENSE file for details.
EOF
    
    echo "ðŸ“¦ Created Python package: ${package_dir}"
    echo "ðŸ“ To get started:"
    echo "   cd ${package_dir}"
    echo "   pip install -e '.[dev]'"
    echo "   pytest"

# Create a new R package
create-r-package name description="Research R package":
    #!/usr/bin/env bash
    package_dir="r/{{name}}"
    mkdir -p "${package_dir}"
    
    # Create R package structure
    mkdir -p "${package_dir}/R"
    mkdir -p "${package_dir}/man"
    mkdir -p "${package_dir}/tests/testthat"
    mkdir -p "${package_dir}/vignettes"
    mkdir -p "${package_dir}/data"
    
    # Generate DESCRIPTION file
    cat > "${package_dir}/DESCRIPTION" << EOF
Package: {{name}}
Type: Package
Title: {{description}}
Version: 0.1.0
Author: {{author_name}} <{{author_email}}>
Maintainer: {{author_name}} <{{author_email}}>
Description: {{description}} developed as part of {{project_name}} research.
License: MIT + file LICENSE
Encoding: UTF-8
LazyData: true
RoxygenNote: 7.2.3
Depends: 
    R (>= 4.1.0)
Imports:
    dplyr,
    ggplot2,
    tibble
Suggests:
    testthat (>= 3.0.0),
    knitr,
    rmarkdown
VignetteBuilder: knitr
EOF
    
    # Create main R functions
    cat > "${package_dir}/R/{{name}}.R" << EOF
#' {{description}}
#'
#' @docType package
#' @name {{name}}
#' @import dplyr
#' @import ggplot2
NULL

#' Research Function
#'
#' This function performs research analysis on the provided data.
#'
#' @param data A data frame containing the research data
#' @param parameter A numeric parameter for the analysis (default: 1.0)
#' @return A processed data frame with research results
#' @export
#' @examples
#' data <- data.frame(x = 1:10, y = rnorm(10))
#' result <- research_function(data, parameter = 2.0)
research_function <- function(data, parameter = 1.0) {
  if (!is.data.frame(data)) {
    stop("Input must be a data frame")
  }
  
  # Implement research logic here
  result <- data %>%
    mutate(across(where(is.numeric), ~ .x * parameter))
  
  return(result)
}

#' Validate Research Data
#'
#' This function validates the quality of research data.
#'
#' @param data A data frame to validate
#' @return A list containing validation results
#' @export
validate_data <- function(data) {
  list(
    nrows = nrow(data),
    ncols = ncol(data),
    missing_values = sapply(data, function(x) sum(is.na(x))),
    data_types = sapply(data, class)
  )
}
EOF
    
    # Create test file
    cat > "${package_dir}/tests/testthat/test-{{name}}.R" << EOF
library(testthat)
library({{name}})

test_that("research_function works correctly", {
  data <- data.frame(x = 1:5, y = 6:10)
  result <- research_function(data, parameter = 2)
  
  expect_equal(result$x, c(2, 4, 6, 8, 10))
  expect_equal(result$y, c(12, 14, 16, 18, 20))
})

test_that("validate_data returns correct structure", {
  data <- data.frame(x = 1:5, y = letters[1:5])
  validation <- validate_data(data)
  
  expect_equal(validation$nrows, 5)
  expect_equal(validation$ncols, 2)
  expect_named(validation, c("nrows", "ncols", "missing_values", "data_types"))
})
EOF
    
    # Create README
    cat > "${package_dir}/README.md" << EOF
# {{name}}

{{description}}

## Installation

```r
# Install from source
devtools::install(".")

# Or install with dependencies
devtools::install(".", dependencies = TRUE)
```

## Usage

```r
library({{name}})

# Example usage
data <- data.frame(x = 1:10, y = rnorm(10))
result <- research_function(data, parameter = 2.0)
```

## Development

```r
# Load package for development
devtools::load_all()

# Run tests
devtools::test()

# Generate documentation
devtools::document()
```

## Citation

If you use this package in your research, please cite:

```
{{author_name}} ({{year}}). {{name}}: {{description}}. 
R package version 0.1.0. https://github.com/{{author_name}}/{{name}}
```
EOF
    
    echo "ðŸ“¦ Created R package: ${package_dir}"
    echo "ðŸ“ To get started:"
    echo "   cd ${package_dir}"
    echo "   R -e 'devtools::load_all()'"
    echo "   R -e 'devtools::test()'"

# Create a CLI tool package
create-cli-tool name description="Research CLI tool":
    #!/usr/bin/env bash
    tool_dir="tools/cli/{{name}}"
    mkdir -p "${tool_dir}"
    
    # Create CLI tool structure
    cat > "${tool_dir}/{{name}}.py" << EOF
#!/usr/bin/env python3
"""{{description}}

A command-line tool for research workflows.
"""

import argparse
import sys
from pathlib import Path
import pandas as pd
import json


def main():
    """Main CLI entry point."""
    parser = argparse.ArgumentParser(
        description="{{description}}",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument(
        "input",
        type=str,
        help="Input file or data"
    )
    
    parser.add_argument(
        "-o", "--output",
        type=str,
        help="Output file (default: stdout)"
    )
    
    parser.add_argument(
        "-p", "--parameter",
        type=float,
        default=1.0,
        help="Analysis parameter (default: 1.0)"
    )
    
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    
    parser.add_argument(
        "--version",
        action="version",
        version="{{name}} 0.1.0"
    )
    
    args = parser.parse_args()
    
    try:
        # Load input data
        if args.verbose:
            print(f"Loading data from: {args.input}", file=sys.stderr)
        
        input_path = Path(args.input)
        if not input_path.exists():
            print(f"Error: Input file not found: {args.input}", file=sys.stderr)
            sys.exit(1)
        
        # Process based on file type
        if input_path.suffix == '.csv':
            data = pd.read_csv(input_path)
        elif input_path.suffix == '.json':
            data = pd.read_json(input_path)
        else:
            print(f"Error: Unsupported file type: {input_path.suffix}", file=sys.stderr)
            sys.exit(1)
        
        # Perform analysis
        if args.verbose:
            print(f"Processing {len(data)} rows with parameter {args.parameter}", file=sys.stderr)
        
        # Example processing - replace with actual research logic
        result = data.copy()
        numeric_cols = result.select_dtypes(include=['number']).columns
        result[numeric_cols] *= args.parameter
        
        # Output results
        if args.output:
            output_path = Path(args.output)
            if output_path.suffix == '.csv':
                result.to_csv(output_path, index=False)
            elif output_path.suffix == '.json':
                result.to_json(output_path, orient='records', indent=2)
            else:
                print(f"Error: Unsupported output type: {output_path.suffix}", file=sys.stderr)
                sys.exit(1)
            
            if args.verbose:
                print(f"Results saved to: {args.output}", file=sys.stderr)
        else:
            # Output to stdout
            print(result.to_csv(index=False))
    
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
EOF
    
    # Make executable
    chmod +x "${tool_dir}/{{name}}.py"
    
    # Create test script
    cat > "${tool_dir}/test_{{name}}.py" << EOF
#!/usr/bin/env python3
"""Tests for {{name}} CLI tool."""

import subprocess
import tempfile
import pandas as pd
from pathlib import Path


def test_cli_basic():
    """Test basic CLI functionality."""
    # Create test data
    test_data = pd.DataFrame({
        'x': [1, 2, 3],
        'y': [4, 5, 6]
    })
    
    with tempfile.NamedTemporaryFile(mode='w', suffix='.csv', delete=False) as f:
        test_data.to_csv(f.name, index=False)
        
        # Run CLI tool
        result = subprocess.run([
            'python3', '{{name}}.py', f.name, '--parameter', '2.0'
        ], capture_output=True, text=True)
        
        assert result.returncode == 0
        
        # Parse output
        output_data = pd.read_csv(pd.StringIO(result.stdout))
        expected = test_data * 2.0
        
        pd.testing.assert_frame_equal(output_data, expected)
    
    # Clean up
    Path(f.name).unlink()


if __name__ == "__main__":
    test_cli_basic()
    print("All tests passed!")
EOF
    
    chmod +x "${tool_dir}/test_{{name}}.py"
    
    # Create README
    cat > "${tool_dir}/README.md" << EOF
# {{name}}

{{description}}

## Usage

```bash
# Basic usage
./{{name}}.py input.csv

# With output file
./{{name}}.py input.csv -o output.csv

# With custom parameter
./{{name}}.py input.csv --parameter 2.5

# Verbose mode
./{{name}}.py input.csv -v
```

## Options

- `-o, --output`: Output file (default: stdout)
- `-p, --parameter`: Analysis parameter (default: 1.0)
- `-v, --verbose`: Enable verbose output
- `--version`: Show version information

## Testing

```bash
python3 test_{{name}}.py
```
EOF
    
    echo "ðŸ”§ Created CLI tool: ${tool_dir}"
    echo "ðŸ“ To test:"
    echo "   cd ${tool_dir}"
    echo "   python3 test_{{name}}.py"

# Create a PowerShell module
create-powershell-module name description="Research PowerShell module":
    #!/usr/bin/env bash
    module_dir="powershell/{{name}}"
    mkdir -p "${module_dir}"
    
    # Create PowerShell module structure
    mkdir -p "${module_dir}/Public"
    mkdir -p "${module_dir}/Private"
    mkdir -p "${module_dir}/Tests"
    mkdir -p "${module_dir}/en-US"
    mkdir -p "${module_dir}/Docs"
    
    # Generate module manifest
    cat > "${module_dir}/{{name}}.psd1" << 'EOF'
@{
    RootModule = '{{name}}.psm1'
    ModuleVersion = '0.1.0'
    GUID = '{{guid}}'
    Author = '{{author_name}}'
    CompanyName = '{{project_name}}'
    Copyright = '(c) {{year}} {{author_name}}. All rights reserved.'
    Description = '{{description}}'
    PowerShellVersion = '5.1'
    FunctionsToExport = @('*')
    CmdletsToExport = @()
    VariablesToExport = '*'
    AliasesToExport = @()
    PrivateData = @{
        PSData = @{
            Tags = @('Research', 'DataScience', 'Academic')
            LicenseUri = 'https://github.com/{{author_name}}/{{name}}/blob/main/LICENSE'
            ProjectUri = 'https://github.com/{{author_name}}/{{name}}'
            ReleaseNotes = 'Initial release'
        }
    }
}
EOF
    
    # Generate module file
    cat > "${module_dir}/{{name}}.psm1" << 'EOF'
<#
.SYNOPSIS
    {{description}}
    
.DESCRIPTION
    A PowerShell module for research workflows developed as part of {{project_name}}.
    
.AUTHOR
    {{author_name}}
    
.VERSION
    0.1.0
#>

# Get public and private function definition files
$Public = @(Get-ChildItem -Path $PSScriptRoot\Public\*.ps1 -ErrorAction SilentlyContinue)
$Private = @(Get-ChildItem -Path $PSScriptRoot\Private\*.ps1 -ErrorAction SilentlyContinue)

# Dot source the files
foreach ($import in @($Public + $Private)) {
    try {
        Write-Verbose "Importing $($import.FullName)"
        . $import.FullName
    }
    catch {
        Write-Error "Failed to import function $($import.FullName): $_"
    }
}

# Export only the public functions
Export-ModuleMember -Function $Public.BaseName
EOF
    
    # Create main research function
    cat > "${module_dir}/Public/Invoke-ResearchAnalysis.ps1" << 'EOF'
function Invoke-ResearchAnalysis {
    <#
    .SYNOPSIS
        Performs research analysis on provided data.
    
    .DESCRIPTION
        This function demonstrates the structure for implementing research
        algorithms in PowerShell with proper documentation and parameter validation.
    
    .PARAMETER InputData
        The input data for analysis (CSV file path or PSObject array)
    
    .PARAMETER Parameter
        Research parameter for analysis (default: 1.0)
    
    .PARAMETER OutputPath
        Optional output file path for results
    
    .EXAMPLE
        PS> Invoke-ResearchAnalysis -InputData "data.csv" -Parameter 2.0
        
    .EXAMPLE
        PS> $data | Invoke-ResearchAnalysis -Parameter 1.5 -OutputPath "results.csv"
    
    .OUTPUTS
        PSObject array containing processed research results
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateNotNullOrEmpty()]
        $InputData,
        
        [Parameter()]
        [ValidateRange(0.1, 100.0)]
        [double]$Parameter = 1.0,
        
        [Parameter()]
        [string]$OutputPath
    )
    
    begin {
        Write-Verbose "Starting research analysis with parameter: $Parameter"
        $Results = @()
    }
    
    process {
        try {
            # Handle different input types
            if ($InputData -is [string] -and (Test-Path $InputData)) {
                Write-Verbose "Loading data from file: $InputData"
                $Data = Import-Csv -Path $InputData
            }
            elseif ($InputData -is [array] -or $InputData -is [System.Collections.IEnumerable]) {
                $Data = $InputData
            }
            else {
                throw "Invalid input data type. Expected CSV file path or PSObject array."
            }
            
            # Process each data item
            foreach ($Item in $Data) {
                $ProcessedItem = $Item.PSObject.Copy()
                
                # Apply research algorithm (example: multiply numeric properties)
                foreach ($Property in $Item.PSObject.Properties) {
                    if ($Property.Value -is [double] -or $Property.Value -is [int]) {
                        $ProcessedItem.$($Property.Name) = $Property.Value * $Parameter
                    }
                }
                
                $Results += $ProcessedItem
            }
        }
        catch {
            Write-Error "Error processing data: $_"
            throw
        }
    }
    
    end {
        Write-Verbose "Analysis completed. Processed $($Results.Count) items."
        
        # Output to file if specified
        if ($OutputPath) {
            try {
                $Results | Export-Csv -Path $OutputPath -NoTypeInformation
                Write-Verbose "Results saved to: $OutputPath"
            }
            catch {
                Write-Error "Failed to save results: $_"
            }
        }
        
        # Return results
        return $Results
    }
}
EOF
    
    # Create utility function
    cat > "${module_dir}/Public/Test-ResearchData.ps1" << 'EOF'
function Test-ResearchData {
    <#
    .SYNOPSIS
        Validates research data quality.
    
    .DESCRIPTION
        Performs quality checks on research data including missing values,
        data types, and basic statistics.
    
    .PARAMETER Data
        The data to validate (PSObject array or CSV file path)
    
    .EXAMPLE
        PS> Test-ResearchData -Data "data.csv"
        
    .EXAMPLE
        PS> $myData | Test-ResearchData
    
    .OUTPUTS
        PSObject containing validation results
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true, ValueFromPipeline = $true)]
        [ValidateNotNullOrEmpty()]
        $Data
    )
    
    begin {
        $ValidationResults = @{
            TotalRows = 0
            TotalColumns = 0
            MissingValues = @{}
            DataTypes = @{}
            NumericColumns = @()
            TextColumns = @()
        }
    }
    
    process {
        try {
            # Handle file input
            if ($Data -is [string] -and (Test-Path $Data)) {
                $DataSet = Import-Csv -Path $Data
            }
            else {
                $DataSet = $Data
            }
            
            $ValidationResults.TotalRows = $DataSet.Count
            
            if ($DataSet.Count -gt 0) {
                $FirstRow = $DataSet[0]
                $ValidationResults.TotalColumns = $FirstRow.PSObject.Properties.Count
                
                # Analyze each column
                foreach ($Property in $FirstRow.PSObject.Properties) {
                    $ColumnName = $Property.Name
                    $Values = $DataSet | ForEach-Object { $_.$ColumnName }
                    
                    # Count missing values
                    $MissingCount = ($Values | Where-Object { [string]::IsNullOrWhiteSpace($_) }).Count
                    $ValidationResults.MissingValues[$ColumnName] = $MissingCount
                    
                    # Determine data type
                    $NonEmptyValues = $Values | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }
                    if ($NonEmptyValues.Count -gt 0) {
                        $SampleValue = $NonEmptyValues[0]
                        if ([double]::TryParse($SampleValue, [ref]$null)) {
                            $ValidationResults.DataTypes[$ColumnName] = "Numeric"
                            $ValidationResults.NumericColumns += $ColumnName
                        }
                        else {
                            $ValidationResults.DataTypes[$ColumnName] = "Text"
                            $ValidationResults.TextColumns += $ColumnName
                        }
                    }
                }
            }
        }
        catch {
            Write-Error "Error validating data: $_"
            throw
        }
    }
    
    end {
        return [PSCustomObject]$ValidationResults
    }
}
EOF
    
    # Create private helper function
    cat > "${module_dir}/Private/Write-ResearchLog.ps1" << 'EOF'
function Write-ResearchLog {
    <#
    .SYNOPSIS
        Internal logging function for research operations.
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [string]$Message,
        
        [Parameter()]
        [ValidateSet('Info', 'Warning', 'Error')]
        [string]$Level = 'Info'
    )
    
    $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $LogMessage = "[$Timestamp] [$Level] $Message"
    
    switch ($Level) {
        'Info' { Write-Verbose $LogMessage }
        'Warning' { Write-Warning $LogMessage }
        'Error' { Write-Error $LogMessage }
    }
}
EOF
    
    # Generate Pester tests
    cat > "${module_dir}/Tests/{{name}}.Tests.ps1" << 'EOF'
BeforeAll {
    # Import the module
    Import-Module "$PSScriptRoot\..\{{name}}.psd1" -Force
}

Describe "{{name}} Module Tests" {
    Context "Module Import" {
        It "Should import without errors" {
            { Import-Module "$PSScriptRoot\..\{{name}}.psd1" -Force } | Should -Not -Throw
        }
        
        It "Should export expected functions" {
            $ExportedFunctions = (Get-Module {{name}}).ExportedFunctions.Keys
            $ExportedFunctions | Should -Contain "Invoke-ResearchAnalysis"
            $ExportedFunctions | Should -Contain "Test-ResearchData"
        }
    }
    
    Context "Invoke-ResearchAnalysis" {
        It "Should process simple data correctly" {
            $TestData = @(
                [PSCustomObject]@{ X = 1; Y = 2 }
                [PSCustomObject]@{ X = 3; Y = 4 }
            )
            
            $Result = Invoke-ResearchAnalysis -InputData $TestData -Parameter 2.0
            
            $Result.Count | Should -Be 2
            $Result[0].X | Should -Be 2
            $Result[0].Y | Should -Be 4
            $Result[1].X | Should -Be 6
            $Result[1].Y | Should -Be 8
        }
        
        It "Should handle invalid parameter values" {
            $TestData = @([PSCustomObject]@{ X = 1 })
            { Invoke-ResearchAnalysis -InputData $TestData -Parameter -1 } | Should -Throw
        }
    }
    
    Context "Test-ResearchData" {
        It "Should validate data structure correctly" {
            $TestData = @(
                [PSCustomObject]@{ Name = "Test"; Value = 10; Empty = $null }
                [PSCustomObject]@{ Name = "Test2"; Value = 20; Empty = "" }
            )
            
            $Validation = Test-ResearchData -Data $TestData
            
            $Validation.TotalRows | Should -Be 2
            $Validation.TotalColumns | Should -Be 3
            $Validation.MissingValues["Empty"] | Should -Be 2
            $Validation.DataTypes["Value"] | Should -Be "Numeric"
            $Validation.DataTypes["Name"] | Should -Be "Text"
        }
    }
}
EOF
    
    # Create README
    cat > "${module_dir}/README.md" << 'EOF'
# {{name}}

{{description}}

## Installation

### From PowerShell Gallery (when published)
```powershell
Install-Module -Name {{name}}
```

### Local Development
```powershell
# Clone and import
git clone https://github.com/{{author_name}}/{{name}}.git
Import-Module .\{{name}}\{{name}}.psd1
```

## Usage

```powershell
# Import the module
Import-Module {{name}}

# Perform research analysis
$results = Invoke-ResearchAnalysis -InputData "data.csv" -Parameter 2.0

# Validate data quality
$validation = Test-ResearchData -Data "data.csv"
```

## Functions

### Invoke-ResearchAnalysis
Performs research analysis on provided data with configurable parameters.

### Test-ResearchData
Validates research data quality including missing values and data types.

## Testing

```powershell
# Run Pester tests
Invoke-Pester -Path .\Tests\
```

## Development

```powershell
# Load module for development
Import-Module .\{{name}}.psd1 -Force

# Run specific tests
Invoke-Pester -Path .\Tests\{{name}}.Tests.ps1
```

## Publishing

```powershell
# Publish to PowerShell Gallery
Publish-Module -Path . -NuGetApiKey $apiKey
```

## Citation

If you use this module in your research, please cite:

```
{{author_name}} ({{year}}). {{name}}: {{description}}. 
PowerShell module version 0.1.0. https://github.com/{{author_name}}/{{name}}
```

## License

MIT License - see LICENSE file for details.
EOF
    
    # Replace placeholders with actual values
    guid=$(uuidgen)
    year=$(date +%Y)
    
    # Use portable sed for cross-platform compatibility
    find "${module_dir}" -type f \( -name "*.psd1" -o -name "*.psm1" -o -name "*.ps1" -o -name "*.md" \) -exec sed -i.bak "s/{{guid}}/${guid}/g; s/{{year}}/${year}/g" {} \;
    find "${module_dir}" -name "*.bak" -delete
    
    echo "ðŸ“¦ Created PowerShell module: ${module_dir}"
    echo "ðŸ“ To get started:"
    echo "   cd ${module_dir}"
    echo "   Import-Module .\{{name}}.psd1"
    echo "   Invoke-Pester -Path .\Tests\"

# Create a Clojure library
create-clojure-library name description="Research Clojure library":
    #!/usr/bin/env bash
    lib_dir="clojure/{{name}}"
    mkdir -p "${lib_dir}"
    
    # Create Clojure project structure
    mkdir -p "${lib_dir}/src/{{name}}"
    mkdir -p "${lib_dir}/test/{{name}}"
    mkdir -p "${lib_dir}/resources"
    mkdir -p "${lib_dir}/doc"
    mkdir -p "${lib_dir}/dev"
    
    # Generate deps.edn
    cat > "${lib_dir}/deps.edn" << 'EOF'
{:paths ["src" "resources"]
 :deps {org.clojure/clojure {:mvn/version "1.11.1"}
        org.clojure/data.csv {:mvn/version "1.0.1"}
        org.clojure/data.json {:mvn/version "2.4.0"}
        semantic-csv/semantic-csv {:mvn/version "0.2.1-alpha1"}}
 
 :aliases
 {:test {:extra-paths ["test"]
         :extra-deps {org.clojure/test.check {:mvn/version "1.1.1"}}}
  :dev {:extra-paths ["dev"]
        :extra-deps {org.clojure/tools.namespace {:mvn/version "1.4.4"}
                     org.clojure/tools.deps.alpha {:mvn/version "0.15.1244"}}}
  :build {:deps {io.github.clojure/tools.build {:git/tag "v0.9.4" :git/sha "76b78fe"}
                 slipset/deps-deploy {:mvn/version "0.2.0"}}
          :ns-default build}
  :uberjar {:replace-deps {com.github.seancorfield/depstar {:mvn/version "2.1.303"}}
            :exec-fn hf.depstar/uberjar
            :exec-args {:aot true
                        :jar "{{name}}.jar"
                        :main-class "{{name}}.core"
                        :sync-pom true}}}}
EOF
    
    # Generate pom.xml template
    cat > "${lib_dir}/pom.xml" << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <groupId>{{author_name}}</groupId>
  <artifactId>{{name}}</artifactId>
  <version>0.1.0</version>
  <name>{{name}}</name>
  <description>{{description}}</description>
  <url>https://github.com/{{author_name}}/{{name}}</url>
  <licenses>
    <license>
      <name>MIT License</name>
      <url>https://opensource.org/licenses/MIT</url>
    </license>
  </licenses>
  <developers>
    <developer>
      <name>{{author_name}}</name>
      <email>{{author_email}}</email>
    </developer>
  </developers>
  <scm>
    <url>https://github.com/{{author_name}}/{{name}}</url>
    <connection>scm:git:git://github.com/{{author_name}}/{{name}}.git</connection>
    <developerConnection>scm:git:ssh://git@github.com/{{author_name}}/{{name}}.git</developerConnection>
    <tag>HEAD</tag>
  </scm>
  <dependencies>
    <dependency>
      <groupId>org.clojure</groupId>
      <artifactId>clojure</artifactId>
      <version>1.11.1</version>
    </dependency>
  </dependencies>
  <build>
    <sourceDirectory>src</sourceDirectory>
  </build>
  <repositories>
    <repository>
      <id>clojars</id>
      <url>https://repo.clojars.org/</url>
    </repository>
  </repositories>
</project>
EOF
    
    # Create main namespace
    cat > "${lib_dir}/src/{{name}}/core.clj" << 'EOF'
(ns {{name}}.core
  "{{description}}
  
  A Clojure library for research workflows developed as part of {{project_name}}."
  (:require [clojure.data.csv :as csv]
            [clojure.data.json :as json]
            [clojure.java.io :as io]
            [clojure.string :as str]))

;; Research Component Protocol
(defprotocol ResearchComponent
  "Protocol for research analysis components."
  (fit [this data] "Fit the component to data.")
  (transform [this data] "Transform data using fitted component.")
  (fit-transform [this data] "Fit component and transform data."))

;; Base Research Analyzer
(defrecord ResearchAnalyzer [name config fitted?]
  ResearchComponent
  (fit [this data]
    (println (str "Fitting " name " with " (count data) " samples"))
    (assoc this :fitted? true))
  
  (transform [this data]
    (when-not (:fitted? this)
      (throw (ex-info "Component must be fitted before transform" {:component this})))
    ;; Example transformation - apply parameter to numeric values
    (let [parameter (get-in this [:config :parameter] 1.0)]
      (map #(into {} (for [[k v] %]
                       [k (if (number? v) (* v parameter) v)])) data)))
  
  (fit-transform [this data]
    (-> this
        (fit data)
        (transform data))))

(defn research-analyzer
  "Creates a new research analyzer component."
  ([name] (research-analyzer name {}))
  ([name config]
   (->ResearchAnalyzer name config false)))

;; Data Loading Functions
(defn load-csv
  "Load research data from CSV file."
  [filepath & {:keys [header?] :or {header? true}}]
  (with-open [reader (io/reader filepath)]
    (let [data (csv/read-csv reader)]
      (if header?
        (let [headers (first data)
              rows (rest data)]
          (map #(zipmap (map keyword headers) %) rows))
        (map-indexed #(zipmap (map keyword (range (count %2))) %2) data)))))

(defn load-json
  "Load research data from JSON file."
  [filepath]
  (with-open [reader (io/reader filepath)]
    (json/read reader :key-fn keyword)))

(defn save-csv
  "Save research results to CSV file."
  [data filepath]
  (let [headers (-> data first keys)
        rows (map #(map % headers) data)]
    (with-open [writer (io/writer filepath)]
      (csv/write-csv writer (cons (map name headers) rows)))))

(defn save-json
  "Save research results to JSON file."
  [data filepath]
  (with-open [writer (io/writer filepath)]
    (json/write data writer :escape-unicode false)))

;; Data Validation Functions
(defn validate-data
  "Validate research data quality."
  [data]
  (let [sample (first data)
        columns (keys sample)
        total-rows (count data)]
    {:total-rows total-rows
     :total-columns (count columns)
     :columns columns
     :missing-values (into {} (for [col columns]
                               [col (count (filter #(or (nil? (col %))
                                                        (and (string? (col %))
                                                             (str/blank? (col %)))) data))]))
     :data-types (into {} (for [col columns]
                           [col (let [sample-val (col sample)]
                                 (cond
                                   (number? sample-val) :numeric
                                   (string? sample-val) :text
                                   (boolean? sample-val) :boolean
                                   :else :unknown))]))
     :memory-estimate (* total-rows (count columns) 8)}))

;; Statistical Functions
(defn summary-stats
  "Calculate summary statistics for numeric columns."
  [data]
  (let [numeric-cols (->> (first data)
                          (filter #(number? (val %)))
                          (map key))]
    (into {} (for [col numeric-cols]
               [col (let [values (map col data)
                         sorted-vals (sort values)
                         n (count values)
                         sum (reduce + values)
                         mean (/ sum n)
                         median (if (odd? n)
                                 (nth sorted-vals (/ (dec n) 2))
                                 (/ (+ (nth sorted-vals (/ n 2))
                                      (nth sorted-vals (dec (/ n 2)))) 2))]
                     {:count n
                      :sum sum
                      :mean mean
                      :median median
                      :min (first sorted-vals)
                      :max (last sorted-vals)
                      :std-dev (Math/sqrt (/ (reduce + (map #(Math/pow (- % mean) 2) values))
                                             (dec n)))})]))

;; Research Pipeline Functions
(defn research-pipeline
  "Execute a research analysis pipeline."
  [data & steps]
  (reduce (fn [acc step]
           (if (fn? step)
             (step acc)
             (throw (ex-info "Pipeline step must be a function" {:step step}))))
         data steps))

(defn apply-filter
  "Create a filter step for research pipeline."
  [pred]
  (fn [data]
    (filter pred data)))

(defn apply-transform
  "Create a transform step for research pipeline."
  [transform-fn]
  (fn [data]
    (map transform-fn data)))

(defn apply-analysis
  "Create an analysis step for research pipeline."
  [analysis-fn]
  (fn [data]
    {:data data
     :analysis (analysis-fn data)}))

;; Example research function
(defn research-function
  "Example research function demonstrating the library structure."
  [data & {:keys [parameter] :or {parameter 1.0}}]
  (when-not (sequential? data)
    (throw (ex-info "Data must be a sequence" {:data data})))
  (map #(into {} (for [[k v] %]
                  [k (if (number? v) (* v parameter) v)])) data))

;; Utility Functions
(defn current-timestamp
  "Get current timestamp for research logging."
  []
  (java.time.Instant/now))

(defn log-research
  "Log research operation with timestamp."
  [operation & args]
  (println (str "[" (current-timestamp) "] " operation ": " (str/join ", " args))))
EOF
    
    # Create test file
    cat > "${lib_dir}/test/{{name}}/core_test.clj" << 'EOF'
(ns {{name}}.core-test
  (:require [clojure.test :refer :all]
            [{{name}}.core :refer :all]))

(deftest test-research-analyzer
  (testing "ResearchAnalyzer creation and basic operations"
    (let [analyzer (research-analyzer "test-analyzer" {:parameter 2.0})
          test-data [{:x 1 :y 2} {:x 3 :y 4}]]
      
      (is (= "test-analyzer" (:name analyzer)))
      (is (false? (:fitted? analyzer)))
      
      ;; Test fitting
      (let [fitted-analyzer (fit analyzer test-data)]
        (is (true? (:fitted? fitted-analyzer))))
      
      ;; Test fit-transform
      (let [result (fit-transform analyzer test-data)]
        (is (= 4 (count result)))
        (is (= 2 (:x (first result))))
        (is (= 4 (:y (first result))))))))

(deftest test-data-validation
  (testing "Data validation functionality"
    (let [test-data [{:name "test" :value 10 :empty nil}
                     {:name "test2" :value 20 :empty ""}]
          validation (validate-data test-data)]
      
      (is (= 2 (:total-rows validation)))
      (is (= 3 (:total-columns validation)))
      (is (= 2 (get-in validation [:missing-values :empty])))
      (is (= :text (get-in validation [:data-types :name])))
      (is (= :numeric (get-in validation [:data-types :value]))))))

(deftest test-summary-stats
  (testing "Summary statistics calculation"
    (let [test-data [{:value 1} {:value 2} {:value 3} {:value 4} {:value 5}]
          stats (summary-stats test-data)
          value-stats (:value stats)]
      
      (is (= 5 (:count value-stats)))
      (is (= 15 (:sum value-stats)))
      (is (= 3.0 (:mean value-stats)))
      (is (= 3 (:median value-stats)))
      (is (= 1 (:min value-stats)))
      (is (= 5 (:max value-stats))))))

(deftest test-research-function
  (testing "Basic research function"
    (let [test-data [{:x 1 :y 2} {:x 3 :y 4}]
          result (research-function test-data :parameter 2.0)]
      
      (is (= 2 (count result)))
      (is (= 2 (:x (first result))))
      (is (= 4 (:y (first result))))
      (is (= 6 (:x (second result))))
      (is (= 8 (:y (second result)))))))

(deftest test-research-pipeline
  (testing "Research pipeline execution"
    (let [test-data [{:value 1} {:value 2} {:value 3} {:value 4} {:value 5}]
          result (research-pipeline test-data
                                   (apply-filter #(even? (:value %)))
                                   (apply-transform #(update % :value * 2))
                                   (apply-analysis #(count %)))]
      
      (is (= 2 (count (:data result))))
      (is (= 2 (:analysis result)))
      (is (= 4 (:value (first (:data result))))))))

(deftest test-invalid-inputs
  (testing "Error handling for invalid inputs"
    (is (thrown? Exception (research-function "not-a-sequence")))
    (is (thrown? Exception (transform (research-analyzer "test") [{:x 1}])))))
EOF
    
    # Create build script
    cat > "${lib_dir}/build.clj" << 'EOF'
(ns build
  (:require [clojure.tools.build.api :as b]
            [deps-deploy.deps-deploy :as dd]))

(def lib '{{author_name}}/{{name}})
(def version "0.1.0")
(def class-dir "target/classes")
(def basis (b/create-basis {:project "deps.edn"}))
(def jar-file (format "target/%s-%s.jar" (name lib) version))

(defn clean [_]
  (b/delete {:path "target"}))

(defn jar [_]
  (b/write-pom {:class-dir class-dir
                :lib lib
                :version version
                :basis basis
                :src-dirs ["src"]})
  (b/copy-dir {:src-dirs ["src" "resources"]
               :target-dir class-dir})
  (b/jar {:class-dir class-dir
          :jar-file jar-file}))

(defn deploy [_]
  (dd/deploy {:installer :remote
              :artifact jar-file
              :pom-file (b/pom-path {:lib lib :class-dir class-dir})}))
EOF
    
    # Create README
    cat > "${lib_dir}/README.md" << 'EOF'
# {{name}}

{{description}}

## Installation

### From Clojars (when published)
```clojure
;; Add to deps.edn
{{author_name}}/{{name}} {:mvn/version "0.1.0"}
```

### Local Development
```bash
git clone https://github.com/{{author_name}}/{{name}}.git
cd {{name}}
clj -M:dev
```

## Usage

```clojure
(require '[{{name}}.core :as research])

;; Load and analyze data
(def data (research/load-csv "data.csv"))
(def analyzer (research/research-analyzer "my-analysis" {:parameter 2.0}))
(def results (research/fit-transform analyzer data))

;; Validate data quality
(def validation (research/validate-data data))

;; Calculate summary statistics
(def stats (research/summary-stats data))

;; Use research pipeline
(def pipeline-result
  (research/research-pipeline data
                             (research/apply-filter #(> (:value %) 10))
                             (research/apply-transform #(update % :value * 2))
                             (research/apply-analysis count)))
```

## Core Functions

### Data Loading
- `load-csv` - Load CSV files with optional headers
- `load-json` - Load JSON data files
- `save-csv` / `save-json` - Save results to files

### Analysis Components
- `research-analyzer` - Create configurable analysis components
- `fit` / `transform` / `fit-transform` - Component interface

### Data Quality
- `validate-data` - Comprehensive data validation
- `summary-stats` - Statistical summaries for numeric columns

### Research Pipeline
- `research-pipeline` - Compose analysis steps
- `apply-filter` / `apply-transform` / `apply-analysis` - Pipeline steps

## Testing

```bash
# Run all tests
clj -M:test -m clojure.test.runner

# Run specific test namespace
clj -M:test -m {{name}}.core-test
```

## Building

```bash
# Build JAR
clj -T:build jar

# Clean build artifacts
clj -T:build clean

# Deploy to Clojars
clj -T:build deploy
```

## Development

```bash
# Start REPL
clj -M:dev

# Run tests with file watching
clj -M:test --watch
```

## Citation

If you use this library in your research, please cite:

```
{{author_name}} ({{year}}). {{name}}: {{description}}. 
Clojure library version 0.1.0. https://github.com/{{author_name}}/{{name}}
```

## License

MIT License - see LICENSE file for details.
EOF
    
    echo "ðŸ“¦ Created Clojure library: ${lib_dir}"
    echo "ðŸ“ To get started:"
    echo "   cd ${lib_dir}"
    echo "   clj -M:dev"
    echo "   clj -M:test -m clojure.test.runner"

# Create a new C# library package
create-csharp-package name description="Research C# library":
    #!/usr/bin/env bash
    package_dir="csharp/{{name}}"
    mkdir -p "${package_dir}"
    
    # Create C# project structure
    dotnet new classlib -n "{{name}}" -o "${package_dir}"
    
    # Add test project
    dotnet new xunit -n "{{name}}.Tests" -o "${package_dir}.Tests"
    
    # Create solution and add projects
    dotnet new sln -n "{{name}}" -o "${package_dir}/.."
    dotnet sln "${package_dir}/../{{name}}.sln" add "${package_dir}/{{name}}.csproj"
    dotnet sln "${package_dir}/../{{name}}.sln" add "${package_dir}.Tests/{{name}}.Tests.csproj"
    
    # Add test reference
    dotnet add "${package_dir}.Tests/{{name}}.Tests.csproj" reference "${package_dir}/{{name}}.csproj"
    
    # Copy template files
    if [ -f "templates/csharp-library/README.md" ]; then
        cp "templates/csharp-library/README.md" "${package_dir}/README.md"
    fi
    
    # Create basic research classes
    cat > "${package_dir}/ResearchAnalyzer.cs" << 'EOF'
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace {{name}}
{
    /// <summary>
    /// Main research analysis component for data processing.
    /// </summary>
    public class ResearchAnalyzer
    {
        /// <summary>
        /// Analyzes numerical data and returns statistical results.
        /// </summary>
        /// <param name="data">Array of numerical data to analyze</param>
        /// <returns>Analysis results containing statistical measures</returns>
        public AnalysisResult AnalyzeData(double[] data)
        {
            if (data == null || data.Length == 0)
                throw new ArgumentException("Data cannot be null or empty", nameof(data));

            var mean = data.Average();
            var variance = data.Select(x => Math.Pow(x - mean, 2)).Average();
            var standardDeviation = Math.Sqrt(variance);

            return new AnalysisResult
            {
                Mean = mean,
                StandardDeviation = standardDeviation,
                Variance = variance,
                Count = data.Length,
                Min = data.Min(),
                Max = data.Max()
            };
        }

        /// <summary>
        /// Analyzes numerical data asynchronously.
        /// </summary>
        /// <param name="data">Array of numerical data to analyze</param>
        /// <returns>Task containing analysis results</returns>
        public async Task<AnalysisResult> AnalyzeDataAsync(double[] data)
        {
            return await Task.Run(() => AnalyzeData(data));
        }

        /// <summary>
        /// Analyzes a collection of numerical data.
        /// </summary>
        /// <param name="data">Collection of numerical data to analyze</param>
        /// <returns>Analysis results containing statistical measures</returns>
        public AnalysisResult AnalyzeData(IEnumerable<double> data)
        {
            return AnalyzeData(data.ToArray());
        }
    }
}
EOF
    
    cat > "${package_dir}/AnalysisResult.cs" << 'EOF'
namespace {{name}}
{
    /// <summary>
    /// Container for analysis results with statistical measures.
    /// </summary>
    public class AnalysisResult
    {
        /// <summary>
        /// The arithmetic mean of the analyzed data.
        /// </summary>
        public double Mean { get; set; }

        /// <summary>
        /// The standard deviation of the analyzed data.
        /// </summary>
        public double StandardDeviation { get; set; }

        /// <summary>
        /// The variance of the analyzed data.
        /// </summary>
        public double Variance { get; set; }

        /// <summary>
        /// The number of data points analyzed.
        /// </summary>
        public int Count { get; set; }

        /// <summary>
        /// The minimum value in the analyzed data.
        /// </summary>
        public double Min { get; set; }

        /// <summary>
        /// The maximum value in the analyzed data.
        /// </summary>
        public double Max { get; set; }

        /// <summary>
        /// Returns a string representation of the analysis results.
        /// </summary>
        /// <returns>Formatted string containing all statistical measures</returns>
        public override string ToString()
        {
            return $"Mean: {Mean:F3}, StdDev: {StandardDeviation:F3}, Count: {Count}, Range: [{Min:F3}, {Max:F3}]";
        }
    }
}
EOF
    
    # Create comprehensive test file
    cat > "${package_dir}.Tests/ResearchAnalyzerTests.cs" << 'EOF'
using Xunit;
using System;
using System.Linq;
using {{name}};

namespace {{name}}.Tests
{
    public class ResearchAnalyzerTests
    {
        [Fact]
        public void AnalyzeData_WithValidData_ReturnsCorrectResults()
        {
            // Arrange
            var analyzer = new ResearchAnalyzer();
            var data = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };

            // Act
            var result = analyzer.AnalyzeData(data);

            // Assert
            Assert.Equal(3.0, result.Mean, 3);
            Assert.Equal(5, result.Count);
            Assert.Equal(1.0, result.Min);
            Assert.Equal(5.0, result.Max);
            Assert.True(result.StandardDeviation > 0);
        }

        [Fact]
        public void AnalyzeData_WithEmptyArray_ThrowsArgumentException()
        {
            // Arrange
            var analyzer = new ResearchAnalyzer();
            var data = new double[0];

            // Act & Assert
            Assert.Throws<ArgumentException>(() => analyzer.AnalyzeData(data));
        }

        [Fact]
        public void AnalyzeData_WithNullArray_ThrowsArgumentException()
        {
            // Arrange
            var analyzer = new ResearchAnalyzer();

            // Act & Assert
            Assert.Throws<ArgumentException>(() => analyzer.AnalyzeData(null));
        }

        [Fact]
        public void AnalyzeData_WithSingleValue_ReturnsCorrectResults()
        {
            // Arrange
            var analyzer = new ResearchAnalyzer();
            var data = new double[] { 42.0 };

            // Act
            var result = analyzer.AnalyzeData(data);

            // Assert
            Assert.Equal(42.0, result.Mean);
            Assert.Equal(0.0, result.StandardDeviation);
            Assert.Equal(1, result.Count);
            Assert.Equal(42.0, result.Min);
            Assert.Equal(42.0, result.Max);
        }

        [Fact]
        public async void AnalyzeDataAsync_WithValidData_ReturnsCorrectResults()
        {
            // Arrange
            var analyzer = new ResearchAnalyzer();
            var data = new double[] { 2.0, 4.0, 6.0, 8.0, 10.0 };

            // Act
            var result = await analyzer.AnalyzeDataAsync(data);

            // Assert
            Assert.Equal(6.0, result.Mean, 3);
            Assert.Equal(5, result.Count);
        }
    }

    public class AnalysisResultTests
    {
        [Fact]
        public void ToString_ReturnsFormattedString()
        {
            // Arrange
            var result = new AnalysisResult
            {
                Mean = 3.0,
                StandardDeviation = 1.581,
                Count = 5,
                Min = 1.0,
                Max = 5.0
            };

            // Act
            var str = result.ToString();

            // Assert
            Assert.Contains("Mean: 3.000", str);
            Assert.Contains("Count: 5", str);
        }
    }
}
EOF
    
    echo "ðŸ“¦ Created C# package: ${package_dir}"
    echo "ðŸ“ To get started:"
    echo "   cd ${package_dir}"
    echo "   dotnet restore"
    echo "   dotnet build"
    echo "   dotnet test ../{{name}}.Tests/"

# Test a C# package
test-csharp package:
    #!/usr/bin/env bash
    if [ -d "csharp/{{package}}" ]; then
        cd "csharp/{{package}}"
        dotnet test
    else
        echo "âŒ Package not found: csharp/{{package}}"
        exit 1
    fi

# Build a C# package
build-csharp package:
    #!/usr/bin/env bash
    if [ -d "csharp/{{package}}" ]; then
        cd "csharp/{{package}}"
        dotnet build
    else
        echo "âŒ Package not found: csharp/{{package}}"
        exit 1
    fi

# Create a new Java library package
create-java-package name description="Research Java library":
    #!/usr/bin/env bash
    package_dir="java/{{name}}"
    mkdir -p "${package_dir}"
    
    # Create Java project structure using Maven
    mvn archetype:generate -DgroupId="com.example" -DartifactId="{{name}}" -DarchetypeArtifactId="maven-archetype-quickstart" -DinteractiveMode="false" -Dpackage="com.example"
    
    mv "{{name}}" "${package_dir}"
    
    # Copy template files
    if [ -f "templates/java-library/README.md" ]; then
        cp "templates/java-library/README.md" "${package_dir}/README.md"
    fi
    
    # Enhance pom.xml with research-focused dependencies
    cat > "${package_dir}/pom.xml" << 'EOF'
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>{{name}}</artifactId>
    <version>0.1.0</version>
    <packaging>jar</packaging>

    <name>{{name}}</name>
    <description>{{description}}</description>
    <url>https://github.com/{{author_name}}/{{name}}</url>

    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <junit.version>5.9.2</junit.version>
        <commons-math.version>3.6.1</commons-math.version>
        <slf4j.version>2.0.6</slf4j.version>
    </properties>

    <dependencies>
        <!-- Core Dependencies -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-math3</artifactId>
            <version>${commons-math.version}</version>
        </dependency>
        
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>${slf4j.version}</version>
        </dependency>
        
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-simple</artifactId>
            <version>${slf4j.version}</version>
            <scope>runtime</scope>
        </dependency>

        <!-- Test Dependencies -->
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-engine</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.junit.jupiter</groupId>
            <artifactId>junit-jupiter-params</artifactId>
            <version>${junit.version}</version>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.mockito</groupId>
            <artifactId>mockito-core</artifactId>
            <version>5.1.1</version>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.assertj</groupId>
            <artifactId>assertj-core</artifactId>
            <version>3.24.2</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.10.1</version>
                <configuration>
                    <source>11</source>
                    <target>11</target>
                </configuration>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.0.0-M9</version>
            </plugin>
            
            <plugin>
                <groupId>org.jacoco</groupId>
                <artifactId>jacoco-maven-plugin</artifactId>
                <version>0.8.8</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>prepare-agent</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>report</id>
                        <phase>test</phase>
                        <goals>
                            <goal>report</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-javadoc-plugin</artifactId>
                <version>3.4.1</version>
                <executions>
                    <execution>
                        <id>attach-javadocs</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
            
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>3.2.1</version>
                <executions>
                    <execution>
                        <id>attach-sources</id>
                        <goals>
                            <goal>jar</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>

    <licenses>
        <license>
            <name>MIT License</name>
            <url>https://opensource.org/licenses/MIT</url>
        </license>
    </licenses>

    <developers>
        <developer>
            <name>{{author_name}}</name>
            <email>{{author_email}}</email>
        </developer>
    </developers>

    <scm>
        <connection>scm:git:git://github.com/{{author_name}}/{{name}}.git</connection>
        <developerConnection>scm:git:ssh://github.com:{{author_name}}/{{name}}.git</developerConnection>
        <url>http://github.com/{{author_name}}/{{name}}/tree/main</url>
    </scm>
</project>
EOF
    
    # Create main Java classes
    mkdir -p "${package_dir}/src/main/java/com/example/{{name}}"
    mkdir -p "${package_dir}/src/test/java/com/example/{{name}}"
    
    # Create ResearchAnalyzer class
    cat > "${package_dir}/src/main/java/com/example/{{name}}/ResearchAnalyzer.java" << 'EOF'
package com.example.{{name}};

import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.DoubleStream;

/**
 * Main research analysis component for data processing.
 * 
 * This class provides statistical analysis capabilities for research data,
 * including descriptive statistics and asynchronous processing.
 * 
 * @author {{author_name}}
 * @version 0.1.0
 */
public class ResearchAnalyzer {
    private static final Logger logger = LoggerFactory.getLogger(ResearchAnalyzer.class);
    
    /**
     * Analyzes numerical data and returns statistical results.
     * 
     * @param data Array of numerical data to analyze
     * @return Analysis results containing statistical measures
     * @throws IllegalArgumentException if data is null or empty
     */
    public AnalysisResult analyzeData(double[] data) {
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("Data cannot be null or empty");
        }
        
        logger.debug("Analyzing {} data points", data.length);
        
        DescriptiveStatistics stats = new DescriptiveStatistics();
        Arrays.stream(data).forEach(stats::addValue);
        
        return AnalysisResult.builder()
            .mean(stats.getMean())
            .standardDeviation(stats.getStandardDeviation())
            .variance(stats.getVariance())
            .count(data.length)
            .min(stats.getMin())
            .max(stats.getMax())
            .median(stats.getPercentile(50))
            .build();
    }
    
    /**
     * Analyzes a list of numerical data.
     * 
     * @param data List of numerical data to analyze
     * @return Analysis results containing statistical measures
     */
    public AnalysisResult analyzeData(List<Double> data) {
        if (data == null || data.isEmpty()) {
            throw new IllegalArgumentException("Data cannot be null or empty");
        }
        
        double[] array = data.stream().mapToDouble(Double::doubleValue).toArray();
        return analyzeData(array);
    }
    
    /**
     * Analyzes numerical data asynchronously.
     * 
     * @param data Array of numerical data to analyze
     * @return CompletableFuture containing analysis results
     */
    public CompletableFuture<AnalysisResult> analyzeDataAsync(double[] data) {
        return CompletableFuture.supplyAsync(() -> {
            logger.info("Starting asynchronous analysis of {} data points", data.length);
            AnalysisResult result = analyzeData(data);
            logger.info("Completed asynchronous analysis");
            return result;
        });
    }
    
    /**
     * Filters data based on a threshold.
     * 
     * @param data Input data array
     * @param threshold Minimum value threshold
     * @return Filtered data array
     */
    public double[] filterData(double[] data, double threshold) {
        if (data == null) {
            throw new IllegalArgumentException("Data cannot be null");
        }
        
        return DoubleStream.of(data)
            .filter(value -> value >= threshold)
            .toArray();
    }
    
    /**
     * Normalizes data to the range [0, 1].
     * 
     * @param data Input data array
     * @return Normalized data array
     */
    public double[] normalizeData(double[] data) {
        if (data == null || data.length == 0) {
            throw new IllegalArgumentException("Data cannot be null or empty");
        }
        
        double min = DoubleStream.of(data).min().orElse(0.0);
        double max = DoubleStream.of(data).max().orElse(1.0);
        double range = max - min;
        
        if (range == 0) {
            return data.clone(); // All values are the same
        }
        
        return DoubleStream.of(data)
            .map(value -> (value - min) / range)
            .toArray();
    }
}
EOF
    
    # Create AnalysisResult class
    cat > "${package_dir}/src/main/java/com/example/{{name}}/AnalysisResult.java" << 'EOF'
package com.example.{{name}};

import java.util.Objects;

/**
 * Container for analysis results with statistical measures.
 * 
 * This class is immutable and uses the builder pattern for construction.
 * 
 * @author {{author_name}}
 * @version 0.1.0
 */
public final class AnalysisResult {
    private final double mean;
    private final double standardDeviation;
    private final double variance;
    private final int count;
    private final double min;
    private final double max;
    private final double median;
    
    private AnalysisResult(Builder builder) {
        this.mean = builder.mean;
        this.standardDeviation = builder.standardDeviation;
        this.variance = builder.variance;
        this.count = builder.count;
        this.min = builder.min;
        this.max = builder.max;
        this.median = builder.median;
    }
    
    // Getters
    public double getMean() { return mean; }
    public double getStandardDeviation() { return standardDeviation; }
    public double getVariance() { return variance; }
    public int getCount() { return count; }
    public double getMin() { return min; }
    public double getMax() { return max; }
    public double getMedian() { return median; }
    
    /**
     * Returns the range of the data (max - min).
     * @return data range
     */
    public double getRange() {
        return max - min;
    }
    
    /**
     * Returns the coefficient of variation (standard deviation / mean).
     * @return coefficient of variation
     */
    public double getCoefficientOfVariation() {
        return mean != 0 ? standardDeviation / Math.abs(mean) : Double.NaN;
    }
    
    @Override
    public String toString() {
        return String.format("AnalysisResult{mean=%.3f, stdDev=%.3f, count=%d, range=[%.3f, %.3f]}",
            mean, standardDeviation, count, min, max);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        AnalysisResult that = (AnalysisResult) obj;
        return Double.compare(that.mean, mean) == 0 &&
               Double.compare(that.standardDeviation, standardDeviation) == 0 &&
               Double.compare(that.variance, variance) == 0 &&
               count == that.count &&
               Double.compare(that.min, min) == 0 &&
               Double.compare(that.max, max) == 0 &&
               Double.compare(that.median, median) == 0;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(mean, standardDeviation, variance, count, min, max, median);
    }
    
    public static Builder builder() {
        return new Builder();
    }
    
    public static class Builder {
        private double mean;
        private double standardDeviation;
        private double variance;
        private int count;
        private double min;
        private double max;
        private double median;
        
        public Builder mean(double mean) {
            this.mean = mean;
            return this;
        }
        
        public Builder standardDeviation(double standardDeviation) {
            this.standardDeviation = standardDeviation;
            return this;
        }
        
        public Builder variance(double variance) {
            this.variance = variance;
            return this;
        }
        
        public Builder count(int count) {
            this.count = count;
            return this;
        }
        
        public Builder min(double min) {
            this.min = min;
            return this;
        }
        
        public Builder max(double max) {
            this.max = max;
            return this;
        }
        
        public Builder median(double median) {
            this.median = median;
            return this;
        }
        
        public AnalysisResult build() {
            return new AnalysisResult(this);
        }
    }
}
EOF
    
    # Create comprehensive test file
    cat > "${package_dir}/src/test/java/com/example/{{name}}/ResearchAnalyzerTest.java" << 'EOF'
package com.example.{{name}};

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.Arrays;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import static org.assertj.core.api.Assertions.*;
import static org.junit.jupiter.api.Assertions.*;

/**
 * Comprehensive tests for ResearchAnalyzer class.
 * 
 * @author {{author_name}}
 */
@DisplayName("Research Analyzer Tests")
class ResearchAnalyzerTest {
    
    private ResearchAnalyzer analyzer;
    
    @BeforeEach
    void setUp() {
        analyzer = new ResearchAnalyzer();
    }
    
    @Test
    @DisplayName("Should analyze simple data correctly")
    void testAnalyzeDataBasic() {
        // Given
        double[] data = {1.0, 2.0, 3.0, 4.0, 5.0};
        
        // When
        AnalysisResult result = analyzer.analyzeData(data);
        
        // Then
        assertThat(result.getMean()).isEqualTo(3.0, within(0.001));
        assertThat(result.getCount()).isEqualTo(5);
        assertThat(result.getMin()).isEqualTo(1.0);
        assertThat(result.getMax()).isEqualTo(5.0);
        assertThat(result.getStandardDeviation()).isGreaterThan(0);
        assertThat(result.getMedian()).isEqualTo(3.0);
    }
    
    @Test
    @DisplayName("Should handle single value correctly")
    void testAnalyzeDataSingleValue() {
        // Given
        double[] data = {42.0};
        
        // When
        AnalysisResult result = analyzer.analyzeData(data);
        
        // Then
        assertThat(result.getMean()).isEqualTo(42.0);
        assertThat(result.getStandardDeviation()).isEqualTo(0.0);
        assertThat(result.getCount()).isEqualTo(1);
        assertThat(result.getMin()).isEqualTo(42.0);
        assertThat(result.getMax()).isEqualTo(42.0);
    }
    
    @Test
    @DisplayName("Should throw exception for null data")
    void testAnalyzeDataNullThrows() {
        assertThrows(IllegalArgumentException.class, () -> {
            analyzer.analyzeData((double[]) null);
        });
    }
    
    @Test
    @DisplayName("Should throw exception for empty data")
    void testAnalyzeDataEmptyThrows() {
        assertThrows(IllegalArgumentException.class, () -> {
            analyzer.analyzeData(new double[0]);
        });
    }
    
    @Test
    @DisplayName("Should analyze list data correctly")
    void testAnalyzeDataList() {
        // Given
        List<Double> data = Arrays.asList(2.0, 4.0, 6.0, 8.0, 10.0);
        
        // When
        AnalysisResult result = analyzer.analyzeData(data);
        
        // Then
        assertThat(result.getMean()).isEqualTo(6.0, within(0.001));
        assertThat(result.getCount()).isEqualTo(5);
    }
    
    @Test
    @DisplayName("Should perform async analysis correctly")
    void testAnalyzeDataAsync() throws ExecutionException, InterruptedException {
        // Given
        double[] data = {1.0, 2.0, 3.0, 4.0, 5.0};
        
        // When
        CompletableFuture<AnalysisResult> future = analyzer.analyzeDataAsync(data);
        AnalysisResult result = future.get();
        
        // Then
        assertThat(result.getMean()).isEqualTo(3.0, within(0.001));
        assertThat(result.getCount()).isEqualTo(5);
    }
    
    @Test
    @DisplayName("Should filter data correctly")
    void testFilterData() {
        // Given
        double[] data = {1.0, 2.0, 3.0, 4.0, 5.0};
        double threshold = 3.0;
        
        // When
        double[] filtered = analyzer.filterData(data, threshold);
        
        // Then
        assertThat(filtered).containsExactly(3.0, 4.0, 5.0);
    }
    
    @Test
    @DisplayName("Should normalize data correctly")
    void testNormalizeData() {
        // Given
        double[] data = {0.0, 5.0, 10.0};
        
        // When
        double[] normalized = analyzer.normalizeData(data);
        
        // Then
        assertThat(normalized).containsExactly(0.0, 0.5, 1.0);
    }
    
    @ParameterizedTest
    @ValueSource(doubles = {-1.0, 0.0, 1.0, 2.5, 10.0})
    @DisplayName("Should handle various threshold values")
    void testFilterDataVariousThresholds(double threshold) {
        // Given
        double[] data = {-2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0};
        
        // When
        double[] filtered = analyzer.filterData(data, threshold);
        
        // Then
        assertThat(filtered).allMatch(value -> value >= threshold);
    }
    
    @Test
    @DisplayName("Should calculate derived statistics correctly")
    void testDerivedStatistics() {
        // Given
        double[] data = {10.0, 20.0, 30.0, 40.0, 50.0};
        
        // When
        AnalysisResult result = analyzer.analyzeData(data);
        
        // Then
        assertThat(result.getRange()).isEqualTo(40.0);
        assertThat(result.getCoefficientOfVariation()).isGreaterThan(0);
    }
}
EOF
    
    # Create AnalysisResult test
    cat > "${package_dir}/src/test/java/com/example/{{name}}/AnalysisResultTest.java" << 'EOF'
package com.example.{{name}};

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;

import static org.assertj.core.api.Assertions.*;

/**
 * Tests for AnalysisResult class.
 * 
 * @author {{author_name}}
 */
@DisplayName("Analysis Result Tests")
class AnalysisResultTest {
    
    @Test
    @DisplayName("Should build result using builder pattern")
    void testBuilderPattern() {
        // When
        AnalysisResult result = AnalysisResult.builder()
            .mean(3.0)
            .standardDeviation(1.58)
            .variance(2.5)
            .count(5)
            .min(1.0)
            .max(5.0)
            .median(3.0)
            .build();
        
        // Then
        assertThat(result.getMean()).isEqualTo(3.0);
        assertThat(result.getStandardDeviation()).isEqualTo(1.58);
        assertThat(result.getCount()).isEqualTo(5);
    }
    
    @Test
    @DisplayName("Should format toString correctly")
    void testToString() {
        // Given
        AnalysisResult result = AnalysisResult.builder()
            .mean(3.0)
            .standardDeviation(1.581)
            .count(5)
            .min(1.0)
            .max(5.0)
            .build();
        
        // When
        String str = result.toString();
        
        // Then
        assertThat(str).contains("mean=3.000");
        assertThat(str).contains("count=5");
        assertThat(str).contains("range=[1.000, 5.000]");
    }
    
    @Test
    @DisplayName("Should implement equals and hashCode correctly")
    void testEqualsAndHashCode() {
        // Given
        AnalysisResult result1 = AnalysisResult.builder()
            .mean(3.0)
            .standardDeviation(1.58)
            .count(5)
            .build();
            
        AnalysisResult result2 = AnalysisResult.builder()
            .mean(3.0)
            .standardDeviation(1.58)
            .count(5)
            .build();
            
        AnalysisResult result3 = AnalysisResult.builder()
            .mean(4.0)
            .standardDeviation(1.58)
            .count(5)
            .build();
        
        // Then
        assertThat(result1).isEqualTo(result2);
        assertThat(result1).isNotEqualTo(result3);
        assertThat(result1.hashCode()).isEqualTo(result2.hashCode());
    }
    
    @Test
    @DisplayName("Should calculate range correctly")
    void testGetRange() {
        // Given
        AnalysisResult result = AnalysisResult.builder()
            .min(2.0)
            .max(8.0)
            .build();
        
        // When
        double range = result.getRange();
        
        // Then
        assertThat(range).isEqualTo(6.0);
    }
    
    @Test
    @DisplayName("Should calculate coefficient of variation correctly")
    void testGetCoefficientOfVariation() {
        // Given
        AnalysisResult result = AnalysisResult.builder()
            .mean(10.0)
            .standardDeviation(2.0)
            .build();
        
        // When
        double cv = result.getCoefficientOfVariation();
        
        // Then
        assertThat(cv).isEqualTo(0.2, within(0.001));
    }
}
EOF
    
    echo "ðŸ“¦ Created Java package: ${package_dir}"
    echo "ðŸ“ To get started:"
    echo "   cd ${package_dir}"
    echo "   mvn clean compile"
    echo "   mvn test"
    echo "   mvn package"

# Test a Java package
test-java package:
    #!/usr/bin/env bash
    if [ -d "java/{{package}}" ]; then
        cd "java/{{package}}"
        mvn test
    else
        echo "âŒ Package not found: java/{{package}}"
        exit 1
    fi

# Build a Java package
build-java package:
    #!/usr/bin/env bash
    if [ -d "java/{{package}}" ]; then
        cd "java/{{package}}"
        mvn package
    else
        echo "âŒ Package not found: java/{{package}}"
        exit 1
    fi

# Create a new F# library package
create-fsharp-package name description="Research F# library":
    #!/usr/bin/env bash
    package_dir="fsharp/{{name}}"
    mkdir -p "${package_dir}"
    
    # Create F# project structure
    dotnet new fslib -n "{{name}}" -o "${package_dir}"

    echo "ðŸ“¦ Created F# package: ${package_dir}"
    echo "ðŸ“ To get started with F#, see the ${package_dir}/README.md file."

# Test an F# package
test-fsharp package:
    #!/usr/bin/env bash
    if [ -d "fsharp/{{package}}" ]; then
        cd "fsharp/{{package}}"
        dotnet test
    else
        echo "âŒ Package not found: fsharp/{{package}}"
        exit 1
    fi

# Build an F# package
build-fsharp package:
    #!/usr/bin/env bash
    if [ -d "fsharp/{{package}}" ]; then
        cd "fsharp/{{package}}"
        dotnet build
    else
        echo "âŒ Package not found: fsharp/{{package}}"
        exit 1
    fi

# === PACKAGE MANAGEMENT ===

# List all packages
list-packages:
    @echo "ðŸ“¦ Available Packages:"
    @echo "Python Packages:"
    @find python -maxdepth 1 -type d ! -name python ! -name __pycache__ ! -name experimental | sed 's/python\///g' | grep -v '^$' | sort
    @echo ""
    @echo "R Packages:"
    @find r -maxdepth 1 -type d ! -name r ! -name experimental 2>/dev/null | sed 's/r\///g' | grep -v '^$' | sort || echo "No R packages found"
    @echo ""
    @echo "CLI Tools:"
    @find tools/cli -maxdepth 1 -type d ! -name cli 2>/dev/null | sed 's/tools\/cli\///g' | grep -v '^$' | sort || echo "No CLI tools found"
    @echo ""
    @echo "PowerShell Modules:"
    @find powershell -maxdepth 1 -type d ! -name powershell ! -name experimental 2>/dev/null | sed 's/powershell\///g' | grep -v '^$' | sort || echo "No PowerShell modules found"
    @echo ""
    @echo "Clojure Libraries:"
    @find clojure -maxdepth 1 -type d ! -name clojure ! -name experimental 2>/dev/null | sed 's/clojure\///g' | grep -v '^$' | sort || echo "No Clojure libraries found"

# Install a Python package in development mode
install-python package:
    #!/usr/bin/env bash
    if [ -d "python/{{package}}" ]; then
        cd "python/{{package}}"
        pip install -e ".[dev]"
        echo "âœ… Installed {{package}} in development mode"
    else
        echo "âŒ Package not found: python/{{package}}"
        exit 1
    fi

# Test a Python package
test-python package:
    #!/usr/bin/env bash
    if [ -d "python/{{package}}" ]; then
        cd "python/{{package}}"
        python -m pytest tests/ -v
    else
        echo "âŒ Package not found: python/{{package}}"
        exit 1
    fi

# Test an R package
test-r package:
    #!/usr/bin/env bash
    if [ -d "r/{{package}}" ]; then
        cd "r/{{package}}"
        R -e "devtools::test()"
    else
        echo "âŒ Package not found: r/{{package}}"
        exit 1
    fi

# Test a PowerShell module
test-powershell module:
    #!/usr/bin/env bash
    if [ -d "powershell/{{module}}" ]; then
        cd "powershell/{{module}}"
        if command -v pwsh &> /dev/null; then
            pwsh -Command "Invoke-Pester -Path ./Tests/ -Passthru"
        elif command -v powershell &> /dev/null; then
            powershell -Command "Invoke-Pester -Path ./Tests/ -Passthru"
        else
            echo "âŒ PowerShell not found. Install PowerShell Core (pwsh) or Windows PowerShell"
            exit 1
        fi
    else
        echo "âŒ Module not found: powershell/{{module}}"
        exit 1
    fi

# Test a Clojure library
test-clojure library:
    #!/usr/bin/env bash
    if [ -d "clojure/{{library}}" ]; then
        cd "clojure/{{library}}"
        if command -v clj &> /dev/null; then
            clj -M:test -m clojure.test.runner
        else
            echo "âŒ Clojure CLI not found. Install from https://clojure.org/guides/getting_started"
            exit 1
        fi
    else
        echo "âŒ Library not found: clojure/{{library}}"
        exit 1
    fi

# Build Python package distribution
build-python package:
    #!/usr/bin/env bash
    if [ -d "python/{{package}}" ]; then
        cd "python/{{package}}"
        python -m build
        echo "âœ… Built distribution for {{package}}"
        echo "ðŸ“¦ Files in dist/:"
        ls -la dist/
    else
        echo "âŒ Package not found: python/{{package}}"
        exit 1
    fi

# === VALIDATION AND QUALITY ===

# Validate package structure
validate-package type package:
    #!/usr/bin/env bash
    package_dir="{{type}}/{{package}}"
    
    if [ ! -d "${package_dir}" ]; then
        echo "âŒ Package not found: ${package_dir}"
        exit 1
    fi
    
    echo "ðŸ” Validating {{package}} ({{type}})..."
    
    if [ "{{type}}" = "python" ]; then
        # Python package validation
        required_files=("pyproject.toml" "README.md" "src" "tests")
        for file in "${required_files[@]}"; do
            if [ -e "${package_dir}/${file}" ]; then
                echo "âœ… ${file}"
            else
                echo "âŒ Missing: ${file}"
            fi
        done
        
        # Check for common Python issues
        cd "${package_dir}"
        if command -v black &> /dev/null; then
            echo "ðŸ”§ Checking code formatting..."
            black --check src/ || echo "âš ï¸ Code formatting issues found"
        fi
        
        if command -v flake8 &> /dev/null; then
            echo "ðŸ”§ Checking code style..."
            flake8 src/ || echo "âš ï¸ Code style issues found"
        fi
        
    elif [ "{{type}}" = "r" ]; then
        # R package validation
        required_files=("DESCRIPTION" "README.md" "R" "tests")
        for file in "${required_files[@]}"; do
            if [ -e "${package_dir}/${file}" ]; then
                echo "âœ… ${file}"
            else
                echo "âŒ Missing: ${file}"
            fi
        done
    fi
    
    echo "âœ… Validation complete for {{package}}"

# Run comprehensive tests for all packages
test-all:
    @echo "ðŸ§ª Running tests for all packages..."
    @for pkg in $(find python -maxdepth 1 -type d ! -name python ! -name experimental | sed 's/python\///'); do \
        if [ -n "$pkg" ]; then \
            echo "Testing Python package: $pkg"; \
            just test-python "$pkg" || echo "âŒ Tests failed for $pkg"; \
        fi \
    done
    @for pkg in $(find r -maxdepth 1 -type d ! -name r ! -name experimental 2>/dev/null | sed 's/r\///'); do \
        if [ -n "$pkg" ]; then \
            echo "Testing R package: $pkg"; \
            just test-r "$pkg" || echo "âŒ Tests failed for $pkg"; \
        fi \
    done

# === DOCUMENTATION ===

# Generate documentation for Python package
docs-python package:
    #!/usr/bin/env bash
    if [ -d "python/{{package}}" ]; then
        cd "python/{{package}}"
        
        if [ -d "docs" ]; then
            cd docs
            make html
            echo "ðŸ“š Documentation built for {{package}}"
            echo "Open: docs/_build/html/index.html"
        else
            echo "âš ï¸ No docs directory found. Creating basic documentation..."
            mkdir -p docs
            cd docs
            sphinx-quickstart -q -p "{{package}}" -a "{{author_name}}" --ext-autodoc --ext-viewcode .
            echo "ðŸ“š Basic documentation structure created"
        fi
    else
        echo "âŒ Package not found: python/{{package}}"
        exit 1
    fi

# === DISTRIBUTION ===

# Create distribution package for PyPI
dist-pypi package:
    #!/usr/bin/env bash
    if [ -d "python/{{package}}" ]; then
        cd "python/{{package}}"
        
        # Clean previous builds
        rm -rf dist/ build/ *.egg-info/
        
        # Build distribution
        python -m build
        
        # Check distribution
        python -m twine check dist/*
        
        echo "ðŸ“¦ Distribution ready for {{package}}"
        echo "ðŸ“ To upload to PyPI:"
        echo "   twine upload dist/*"
        echo "ðŸ“ To upload to Test PyPI:"
        echo "   twine upload --repository testpypi dist/*"
    else
        echo "âŒ Package not found: python/{{package}}"
        exit 1
    fi

# Create conda package
dist-conda package:
    #!/usr/bin/env bash
    if [ -d "python/{{package}}" ]; then
        echo "ðŸ—ï¸ Creating conda package for {{package}}..."
        
        # Create conda-build directory structure
        mkdir -p "distribution/conda/{{package}}"
        
        # Generate meta.yaml
        cat > "distribution/conda/{{package}}/meta.yaml" << EOF
{% set name = "{{package}}" %}
{% set version = "0.1.0" %}

package:
  name: {{ name|lower }}
  version: {{ version }}

source:
  path: ../../python/{{package}}

build:
  number: 0
  script: python -m pip install . -vv
  noarch: python

requirements:
  host:
    - python >=3.8
    - pip
    - setuptools
  run:
    - python >=3.8
    - numpy
    - pandas
    - scipy

test:
  imports:
    - {{package}}
  commands:
    - python -c "import {{package}}; print({{package}}.__version__)"

about:
  home: https://github.com/{{author_name}}/{{package}}
  license: MIT
  license_family: MIT
  license_file: LICENSE
  summary: {{description}}
  description: |
    {{description}} developed as part of {{project_name}} research.
  dev_url: https://github.com/{{author_name}}/{{package}}

extra:
  recipe-maintainers:
    - {{author_name}}
EOF
        
        echo "ðŸ“¦ Conda recipe created at distribution/conda/{{package}}/"
        echo "ðŸ“ To build:"
        echo "   conda-build distribution/conda/{{package}}/"
    else
        echo "âŒ Package not found: python/{{package}}"
        exit 1
    fi

# Distribute PowerShell module to PowerShell Gallery
dist-powershell-gallery module:
    #!/usr/bin/env bash
    if [ -d "powershell/{{module}}" ]; then
        cd "powershell/{{module}}"
        echo "ðŸ“¦ Preparing PowerShell module {{module}} for PowerShell Gallery..."
        
        # Validate module manifest
        if command -v pwsh &> /dev/null; then
            pwsh -Command "Test-ModuleManifest -Path ./{{module}}.psd1"
        elif command -v powershell &> /dev/null; then
            powershell -Command "Test-ModuleManifest -Path ./{{module}}.psd1"
        else
            echo "âŒ PowerShell not found"
            exit 1
        fi
        
        echo "ðŸ“¦ Module validated successfully"
        echo "ðŸ“ To publish to PowerShell Gallery:"
        echo "   # Set your API key:"
        echo "   \$apiKey = 'your-powershell-gallery-api-key'"
        echo "   # Publish module:"
        echo "   Publish-Module -Path . -NuGetApiKey \$apiKey"
        echo "   # Or publish to test repository:"
        echo "   Publish-Module -Path . -Repository PSGalleryInt -NuGetApiKey \$apiKey"
    else
        echo "âŒ Module not found: powershell/{{module}}"
        exit 1
    fi

# Build Clojure library JAR
build-clojure library:
    #!/usr/bin/env bash
    if [ -d "clojure/{{library}}" ]; then
        cd "clojure/{{library}}"
        echo "ðŸ—ï¸ Building Clojure library {{library}}..."
        
        if command -v clj &> /dev/null; then
            # Clean previous builds
            clj -T:build clean
            
            # Build JAR
            clj -T:build jar
            
            echo "âœ… JAR built successfully"
            echo "ðŸ“¦ Files in target/:"
            ls -la target/
        else
            echo "âŒ Clojure CLI not found"
            exit 1
        fi
    else
        echo "âŒ Library not found: clojure/{{library}}"
        exit 1
    fi

# Distribute Clojure library to Clojars
dist-clojars library:
    #!/usr/bin/env bash
    if [ -d "clojure/{{library}}" ]; then
        cd "clojure/{{library}}"
        echo "ðŸ“¦ Preparing Clojure library {{library}} for Clojars..."
        
        if command -v clj &> /dev/null; then
            # Build JAR first
            clj -T:build jar
            
            echo "ðŸ“¦ Library built successfully"
            echo "ðŸ“ To deploy to Clojars:"
            echo "   # Set your Clojars credentials in ~/.m2/settings.xml or use environment variables:"
            echo "   # CLOJARS_USERNAME=your-username"
            echo "   # CLOJARS_PASSWORD=your-deploy-token"
            echo "   # Then deploy:"
            echo "   clj -T:build deploy"
            echo "   # Or deploy manually with:"
            echo "   # mvn deploy:deploy-file -DgroupId={{author_name}} -DartifactId={{library}} -Dversion=0.1.0 -Dpackaging=jar -Dfile=target/{{library}}-0.1.0.jar -DrepositoryId=clojars -Durl=https://clojars.org/repo"
        else
            echo "âŒ Clojure CLI not found"
            exit 1
        fi
    else
        echo "âŒ Library not found: clojure/{{library}}"
        exit 1
    fi

# === LEGACY COMMANDS (for backward compatibility) ===

# Compile a Zig file (legacy)
zig-build file:
    #!/usr/bin/env bash
    if command -v zig &> /dev/null; then
        zig build-exe zig/{{file}}.zig -O ReleaseSafe -femit-bin=../pbin/{{file}}
        echo "ðŸ”§ Compiled {{file}} to ../pbin/{{file}}"
    else
        echo "âŒ Zig compiler not found"
        exit 1
    fi

# Run a compiled Zig binary (legacy)
zig-run file:
    #!/usr/bin/env bash
    if [ -f "../pbin/{{file}}" ]; then
        ../pbin/{{file}}
    else
        echo "âŒ Binary not found: ../pbin/{{file}}"
        echo "ðŸ’¡ Try: just zig-build {{file}}"
        exit 1
    fi
